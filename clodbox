#!/usr/bin/env bash
set -euo pipefail

# Load shared library from the same directory as this script.
. "$(dirname "$(realpath "$0")")/clodbox-lib"

# Primary / main function; starts clodbox container.
_clodbox_start_() {
  # Fetch or construct all necessary paths.
  _clodbox_load_std_paths_
  _clodbox_fetch_project_paths_

  # CLI -i/--image overrides any config-sourced image.
  if [ -n "${CLODBOX_IMAGE_OVERRIDE:-}" ]; then
    CLODBOX_CONTAINER_IMAGE="$CLODBOX_IMAGE_OVERRIDE"
  fi

  ENTRYPOINT_ARGS=()
  if [ -n "${CLODBOX_ENTRYPOINT:-}" ]; then
    ENTRYPOINT_ARGS=(--entrypoint "$CLODBOX_ENTRYPOINT")
  fi

  # Refresh auth credentials from central store into project copy.
  CENTRAL_CREDS="$CLODBOX_CREDENTIALS_PATH/$CLODBOX_DOT_PATH/.credentials.json"
  if [ -f "$CENTRAL_CREDS" ]; then
    jq --argjson auth "$(jq '.claudeAiOauth' "$CENTRAL_CREDS")" \
      '.claudeAiOauth = $auth' "$PROJECT_DOT_PATH/.credentials.json" \
      > "$PROJECT_DOT_PATH/.credentials.json.tmp" \
      && mv "$PROJECT_DOT_PATH/.credentials.json.tmp" "$PROJECT_DOT_PATH/.credentials.json"
  fi

  # Build CLI args to pass to the container entrypoint.
  CLI_ARGS=()

  # Determine if we're in claude mode (entrypoint is claude, not overridden).
  CLODBOX_CLAUDE_MODE=1
  if [ -n "${CLODBOX_ENTRYPOINT:-}" ]; then
    CLODBOX_CLAUDE_MODE=
  fi

  if [ -n "$CLODBOX_CLAUDE_MODE" ]; then
    # Inject --dangerously-skip-permissions unless --safe was passed.
    if [ -z "${CLODBOX_SAFE_MODE:-}" ]; then
      CLI_ARGS+=(--dangerously-skip-permissions)
    fi

    if [ -n "${CLODBOX_RESUME_MODE:-}" ]; then
      # Resume mode: inject --resume, skip --continue logic.
      CLI_ARGS+=(--resume)
    else
      # Default to --continue for existing projects, unless suppressed.
      SKIP_CONTINUE="${CLODBOX_NEW_SESSION:-}${CLODBOX_PROJECT_IS_NEW:-}"
      for arg in "$@"; do
        if [ "$arg" = "--resume" ] || [ "$arg" = "-r" ]; then
          SKIP_CONTINUE=1
        fi
      done
      if [ -z "$SKIP_CONTINUE" ]; then
        CLI_ARGS+=(--continue)
      fi
    fi
  fi

  CLI_ARGS+=("$@")

  # Execute podman or docker.
  docker run -it --rm --userns=keep-id \
    -v "$PROJECT_PATH":/home/agent/workspace:Z,U \
    -w /home/agent/workspace \
    -v "$PROJECT_DOT_PATH":/home/agent/.claude:Z,U \
    -v "$PROJECT_CFG_FILE":/home/agent/.claude.json:Z,U \
    "${ENTRYPOINT_ARGS[@]}" \
    "$CLODBOX_CONTAINER_IMAGE" \
    "${CLI_ARGS[@]}"
}

# Process standardized directories.
_clodbox_load_std_paths_() {
  # Fetch / normalize XDG variables (or get their defaults)
  XDG_DATA_HOME=$(_get_abspath_ "${XDG_DATA_HOME:-}" "$HOME/.local/share")
  XDG_STATE_HOME=$(_get_abspath_ "${XDG_STATE_HOME:-}" "$HOME/.local/state")
  XDG_CACHE_HOME=$(_get_abspath_ "${XDG_CACHE_HOME:-}" "$HOME/.cache")

  # The config has all over variables, so just this relative path is at the top;
  # it holds important values - all of the relative paths, as well as others
  # (CLODBOX_CREDENTIALS_PATH, CLODBOX_SETTINGS_PATH). Other standard paths use
  # the standard relative path loaded from the config file.

  if [ ! -f "$CLODBOX_CONFIG_FILE" ]; then
    echo "Error: [$CLODBOX_CONFIG_FILE] is missing. Reinstall to fix." >&2
    exit 1
  else
    . "$CLODBOX_CONFIG_FILE"
  fi

  CLODBOX_DATA_PATH="$XDG_DATA_HOME/$CLODBOX_RELATIVE_STD_PATH" # projects, creds.
  CLODBOX_STATE_PATH="$XDG_STATE_HOME/$CLODBOX_RELATIVE_STD_PATH" # Maybe for later
  CLODBOX_CACHE_PATH="$XDG_CACHE_HOME/$CLODBOX_RELATIVE_STD_PATH" # Maybe for later
  CLODBOX_CREDENTIALS_PATH="$CLODBOX_DATA_PATH/$CLODBOX_INIT_CREDENTIALS_PATH"

  # Make sure all of the directories exist.
  mkdir -p "$(dirname "$CLODBOX_CONFIG_FILE")"
  mkdir -p "$CLODBOX_DATA_PATH"
  mkdir -p "$CLODBOX_STATE_PATH"
  mkdir -p "$CLODBOX_CACHE_PATH"
}

# Fetch / construct and validate project paths.
_clodbox_fetch_project_paths_() {
  # Fetch / construct various project-related paths
  PROJECT_PATH="$(realpath -m "${CLODBOX_PROJECT_DIR:-$(pwd)}")"
  PROJECT_HASH=$(echo -n "$PROJECT_PATH" | sha256sum | cut -d " " -f1)

  PROJECT_SETTINGS_PATH="$CLODBOX_DATA_PATH/$CLODBOX_PROJECTS_PATH/$PROJECT_HASH"
  PROJECT_DOT_PATH="$PROJECT_SETTINGS_PATH/$CLODBOX_DOT_PATH"
  PROJECT_CFG_FILE="$PROJECT_SETTINGS_PATH/$CLODBOX_CFG_FILE"

  # If the project path doesn't exist... something is wrong.
  if [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Project path '$PROJECT_PATH' does not exist." >&2
    echo "(How did you get here?!)" >&2
    exit 1
  fi

  # If there's no data on the project, attempt to initialize it freshly.
  if [ ! -d "$PROJECT_SETTINGS_PATH" ]; then
    printf '[One Time Setup] Initializing clodbox in %s... ' "$PROJECT_PATH"
    _clodbox_init_
    printf "done.\n"
    CLODBOX_PROJECT_IS_NEW=1
  fi

  # If dot-path doesn't exist at this point, its a problem; attempt recovery.
  if [ ! -d "$PROJECT_DOT_PATH" ]; then
    echo "Warning: No settings directory; this is probably a problem." >&2
    echo "--> Making project settings directory for attempted start..."
    mkdir -p "$PROJECT_DOT_PATH"
    if [ ! -d "$PROJECT_DOT_PATH" ]; then
      echo "Error: *Still* no project settings directory. Exiting." >&2
      exit 1
    fi
  fi

  # Source per-project config if it exists (overrides global defaults).
  PROJECT_RC="$PROJECT_SETTINGS_PATH/project.rc"
  if [ -f "$PROJECT_RC" ]; then
    . "$PROJECT_RC"
  fi

  # If the config file doesn't exist, that's also a problem - attempt recovery.
  if [ ! -f "$PROJECT_CFG_FILE" ]; then
    echo "Warning: No project config file; this is probably a problem." >&2
    echo "--> Creating $PROJECT_CFG_FILE..."
    touch "$PROJECT_CFG_FILE"
    if [ ! -f "$PROJECT_CFG_FILE" ]; then
      echo "Error: *Still* no project config file. Exiting." >&2
      exit 1
    fi
  fi
}

# Initialize clodbox in current working path.
_clodbox_init_() {
  # Check if path exists. (It should always exist.)
  if [ ! -d "$PROJECT_PATH" ]; then
    echo "Function Error: clodbox project directory doesn't exist." >&2
    echo "(How did you get here?!)" >&2
    exit 1
  fi

  # Fetch project-specific path via hash. Generate missing directories.
  mkdir -p "$PROJECT_PATH"
  mkdir -p "$PROJECT_SETTINGS_PATH"

  # Copy credential files into the project configuration and exit.
  cp -rp "$CLODBOX_CREDENTIALS_PATH/." "$PROJECT_SETTINGS_PATH"
}

# Archive project session data and git metadata.
_clodbox_archive_() {
  local project_path="${1:-}"
  local archive_file="${2:-}"

  if [ -z "$project_path" ]; then
    echo "Error: Project path required." >&2
    echo "Usage: clodbox archive <project-path> [archive-file]" >&2
    exit 1
  fi

  # Override project dir and load paths
  CLODBOX_PROJECT_DIR="$project_path"
  _clodbox_load_std_paths_
  _clodbox_fetch_project_paths_

  # Check if session data exists
  if [ ! -d "$PROJECT_SETTINGS_PATH" ]; then
    echo "Error: No session data found for project $PROJECT_PATH" >&2
    exit 1
  fi

  # Generate default archive filename if not provided
  if [ -z "$archive_file" ]; then
    local basename=$(basename "$PROJECT_PATH")
    local hash8="${PROJECT_HASH:0:8}"
    local timestamp=$(date -u +%Y%m%dT%H%M%SZ)
    archive_file="clodbox-${basename}-${hash8}-${timestamp}.txz"
  fi

  # Prepare metadata
  local info_file="$PROJECT_SETTINGS_PATH/clodbox-archive-info.txt"
  echo "Project path: $PROJECT_PATH" > "$info_file"
  echo "Project hash: $PROJECT_HASH" >> "$info_file"
  echo "Archive date: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$info_file"
  echo "" >> "$info_file"

  # Check if project is a git repo
  if [ -d "$PROJECT_PATH/.git" ]; then
    cd "$PROJECT_PATH"

    # Check for uncommitted changes unless allowed
    if [ -z "${CLODBOX_ALLOW_UNCOMMITTED:-}" ]; then
      if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        echo "Error: Uncommitted changes detected." >&2
        echo "Commit your changes or use --allow-uncommitted to override." >&2
        rm -f "$info_file"
        exit 1
      fi
    fi

    # Check for unpushed commits unless allowed
    if [ -z "${CLODBOX_ALLOW_UNPUSHED:-}" ]; then
      local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
      local upstream=$(git rev-parse --abbrev-ref @{upstream} 2>/dev/null || echo "")
      if [ -n "$upstream" ]; then
        local unpushed=$(git rev-list "$upstream..HEAD" --count 2>/dev/null || echo "0")
        if [ "$unpushed" -gt 0 ]; then
          echo "Error: $unpushed unpushed commit(s) detected." >&2
          echo "Push your changes or use --allow-unpushed to override." >&2
          rm -f "$info_file"
          exit 1
        fi
      fi
    fi

    # Record git metadata
    echo "Git repository: yes" >> "$info_file"
    echo "Branch: $(git rev-parse --abbrev-ref HEAD)" >> "$info_file"
    echo "Commit: $(git rev-parse HEAD)" >> "$info_file"
    echo "Remotes:" >> "$info_file"
    git remote -v | grep '(fetch)' | awk '{print "  " $1 ": " $2}' >> "$info_file"
  else
    echo "Warning: No git repository detected in $PROJECT_PATH" >&2
    echo "Only clodbox session data will be archived." >&2
    echo "" >> "$info_file"
    echo "Git repository: no" >> "$info_file"
  fi

  # Create archive
  printf "Creating archive %s... " "$archive_file"
  tar -cJf "$archive_file" -C "$CLODBOX_DATA_PATH/$CLODBOX_PROJECTS_PATH" "$PROJECT_HASH"
  rm -f "$info_file"
  printf "done.\n"
  echo "Archive created: $archive_file"
}

# Clean project session data.
_clodbox_clean_() {
  local project_path="${1:-}"

  if [ -z "$project_path" ]; then
    echo "Error: Project path required." >&2
    echo "Usage: clodbox clean <project-path>" >&2
    exit 1
  fi

  # Override project dir and load paths
  CLODBOX_PROJECT_DIR="$project_path"
  _clodbox_load_std_paths_
  _clodbox_fetch_project_paths_

  # Check if session data exists
  if [ ! -d "$PROJECT_SETTINGS_PATH" ]; then
    echo "No session data found for project $PROJECT_PATH"
    exit 0
  fi

  # Prompt for confirmation unless forced
  if [ -z "${CLODBOX_FORCE:-}" ]; then
    local hash8="${PROJECT_HASH:0:8}"
    echo "Project: $PROJECT_PATH"
    echo "Hash: $hash8"
    echo ""
    printf "Delete all session data for this project? This cannot be undone.\nType 'yes' to confirm: "
    read -r response
    if [ "$response" != "yes" ]; then
      echo "Aborted."
      exit 0
    fi
  fi

  # Remove session data
  printf "Removing session data... "
  rm -rf "$PROJECT_SETTINGS_PATH"
  printf "done.\n"
  echo "Session data removed for $PROJECT_PATH"
}

# Restore project session data from archive.
_clodbox_restore_() {
  local project_path="${1:-}"
  local archive_file="${2:-}"

  if [ -z "$project_path" ] || [ -z "$archive_file" ]; then
    echo "Error: Project path and archive file required." >&2
    echo "Usage: clodbox restore <project-path> <archive-file>" >&2
    exit 1
  fi

  if [ ! -f "$archive_file" ]; then
    echo "Error: Archive file not found: $archive_file" >&2
    exit 1
  fi

  # Override project dir and load paths
  CLODBOX_PROJECT_DIR="$project_path"
  _clodbox_load_std_paths_
  _clodbox_fetch_project_paths_

  # Extract metadata from archive
  local temp_dir=$(mktemp -d)
  trap "rm -rf $temp_dir" EXIT

  tar -xJf "$archive_file" -C "$temp_dir" 2>/dev/null
  local archive_hash=$(ls "$temp_dir" | head -n1)
  local info_file="$temp_dir/$archive_hash/clodbox-archive-info.txt"

  if [ ! -f "$info_file" ]; then
    echo "Error: Invalid archive format (missing clodbox-archive-info.txt)" >&2
    exit 1
  fi

  local archive_path=$(grep "^Project path:" "$info_file" | cut -d' ' -f3-)
  local archive_basename=$(basename "$archive_path")
  local current_basename=$(basename "$PROJECT_PATH")

  # Validate hash match
  local hash_match=0
  if [ "$archive_hash" = "$PROJECT_HASH" ]; then
    hash_match=1
  elif [ "$archive_basename" = "$current_basename" ]; then
    hash_match=1  # Same basename, different parent path
  fi

  if [ $hash_match -eq 0 ] && [ -z "${CLODBOX_FORCE:-}" ]; then
    echo "Warning: Project path mismatch"
    echo ""
    echo "Archive from: $archive_path"
    echo "Restoring to: $PROJECT_PATH"
    echo ""
    printf "Continue anyway? Type 'yes' to confirm: "
    read -r response
    if [ "$response" != "yes" ]; then
      echo "Aborted."
      exit 0
    fi
  fi

  # Validate git state if archive has git metadata
  local git_in_archive=$(grep "^Git repository:" "$info_file" | cut -d' ' -f3)
  if [ "$git_in_archive" = "yes" ]; then
    if [ ! -d "$PROJECT_PATH/.git" ]; then
      if [ -z "${CLODBOX_FORCE:-}" ]; then
        echo "Warning: Archive came from a git repository, but current workspace is not a git repo."
        echo ""
        grep "^Branch:\|^Commit:\|^Remotes:" "$info_file" | head -n3
        echo ""
        printf "Continue anyway? Type 'yes' to confirm: "
        read -r response
        if [ "$response" != "yes" ]; then
          echo "Aborted."
          exit 0
        fi
      fi
    else
      cd "$PROJECT_PATH"
      local archive_commit=$(grep "^Commit:" "$info_file" | awk '{print $2}')
      local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "")

      if [ "$archive_commit" != "$current_commit" ] && [ -z "${CLODBOX_FORCE:-}" ]; then
        echo "Warning: Git state mismatch"
        echo ""
        echo "Archive from:"
        grep "^Branch:\|^Commit:" "$info_file" | sed 's/^/  /'
        echo ""
        echo "Current workspace:"
        echo "  Branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')"
        echo "  Commit: $current_commit"
        echo ""
        printf "Continue anyway? Type 'yes' to confirm: "
        read -r response
        if [ "$response" != "yes" ]; then
          echo "Aborted."
          exit 0
        fi
      fi
    fi
  fi

  # Restore session data
  printf "Restoring session data... "
  mkdir -p "$CLODBOX_DATA_PATH/$CLODBOX_PROJECTS_PATH"
  rm -rf "$PROJECT_SETTINGS_PATH"
  cp -rp "$temp_dir/$archive_hash" "$PROJECT_SETTINGS_PATH"
  # Remove the info file from the restored data
  rm -f "$PROJECT_SETTINGS_PATH/clodbox-archive-info.txt"
  printf "done.\n"
  echo "Session data restored to $PROJECT_PATH"
}

# Get or set per-project configuration.
_clodbox_config_() {
  local key="${1:-}"
  if [ -z "$key" ]; then
    echo "Usage: clodbox config <key> [value]" >&2
    echo "Keys: image" >&2
    exit 1
  fi

  case "$key" in
    image)
      if [ -z "${2:-}" ]; then
        echo "$CLODBOX_CONTAINER_IMAGE"
      else
        local rc="$PROJECT_SETTINGS_PATH/project.rc"
        if [ -f "$rc" ] && grep -q '^CLODBOX_CONTAINER_IMAGE=' "$rc"; then
          sed -i "s|^CLODBOX_CONTAINER_IMAGE=.*|CLODBOX_CONTAINER_IMAGE=\"$2\"|" "$rc"
        else
          echo "CLODBOX_CONTAINER_IMAGE=\"$2\"" >> "$rc"
        fi
        echo "Set image to $2 for project $PROJECT_PATH"
      fi
      ;;
    *)
      echo "Error: Unknown config key: $key" >&2
      exit 1
      ;;
  esac
}

# ---- Option Processing ----
_clodbox_usage_() {
  echo "Usage: clodbox [OPTIONS] [COMMAND] [-- AGENT_ARGS...]"
  echo ""
  echo "Commands:"
  echo "  start              Start or continue a Claude session (default)"
  echo "  shell              Open a bash shell in the container"
  echo "  resume             Resume with conversation picker"
  echo "  config             Get or set per-project configuration"
  echo "  archive <path> [file]  Archive project session data to .txz file"
  echo "  clean <path>       Remove project session data"
  echo "  restore <path> <file>  Restore session data from archive"
  echo ""
  echo "Options:"
  echo "  -c, --command CMD      Use CMD as the container entrypoint"
  echo "  -i, --image IMAGE      Use IMAGE as the container image for this run"
  echo "  -p, --project DIR      Use DIR as the project directory (default: cwd)"
  echo "  -N, --new              Start a new conversation (skip default --continue)"
  echo "  -S, --safe             Run without --dangerously-skip-permissions"
  echo "  -h, --help             Show this help message"
  echo ""
  echo "Archive/Clean/Restore Options:"
  echo "  --allow-uncommitted    Allow archiving with uncommitted changes"
  echo "  --allow-unpushed       Allow archiving with unpushed commits"
  echo "  --force                Skip all confirmation prompts"
  echo ""
  echo "By default, existing projects resume the last conversation. Use -N to"
  echo "start fresh, or pass explicit agent args after -- to override."
}

CLODBOX_SUBCOMMAND=
CLODBOX_ALLOW_UNCOMMITTED=
CLODBOX_ALLOW_UNPUSHED=
CLODBOX_FORCE=

while [ $# -gt 0 ]; do
  case "$1" in
    --allow-uncommitted)
      CLODBOX_ALLOW_UNCOMMITTED=1
      shift
      ;;
    --allow-unpushed)
      CLODBOX_ALLOW_UNPUSHED=1
      shift
      ;;
    --force)
      CLODBOX_FORCE=1
      shift
      ;;
    -c|--command|-E|--entrypoint)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_ENTRYPOINT="$2"
      shift 2
      ;;
    -i|--image)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_IMAGE_OVERRIDE="$2"
      shift 2
      ;;
    -p|--project)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_PROJECT_DIR="$2"
      shift 2
      ;;
    -N|--new)
      CLODBOX_NEW_SESSION=1
      shift
      ;;
    -S|--safe)
      CLODBOX_SAFE_MODE=1
      shift
      ;;
    -h|--help)
      _clodbox_usage_
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      _clodbox_usage_ >&2
      exit 1
      ;;
    start|shell|resume|config|archive|clean|restore)
      CLODBOX_SUBCOMMAND="$1"
      shift
      break
      ;;
    *)
      echo "Error: Unknown command: $1" >&2
      _clodbox_usage_ >&2
      exit 1
      ;;
  esac
done

# Default subcommand is start.
CLODBOX_SUBCOMMAND="${CLODBOX_SUBCOMMAND:-start}"

# Apply subcommand effects.
case "$CLODBOX_SUBCOMMAND" in
  config)
    _clodbox_load_std_paths_
    _clodbox_fetch_project_paths_
    _clodbox_config_ "$@"
    exit 0
    ;;
  archive)
    _clodbox_archive_ "$@"
    exit 0
    ;;
  clean)
    _clodbox_clean_ "$@"
    exit 0
    ;;
  restore)
    _clodbox_restore_ "$@"
    exit 0
    ;;
  shell)
    CLODBOX_ENTRYPOINT="/bin/bash"
    ;;
  resume)
    CLODBOX_RESUME_MODE=1
    ;;
esac

# Kickoff the script; forward any remaining args to the container.
_clodbox_start_ "$@"
