#!/usr/bin/env bash
set -euo pipefail

# Load shared library from the same directory as this script.
. "$(dirname "$(realpath "$0")")/clodbox-lib"

# Primary / main function; starts clodbox container.
_clodbox_start_() {
  # Fetch or construct all necessary paths.
  _clodbox_load_std_paths_
  _clodbox_fetch_project_paths_

  # CLI -i/--image overrides any config-sourced image.
  if [ -n "${CLODBOX_IMAGE_OVERRIDE:-}" ]; then
    CLODBOX_CONTAINER_IMAGE="$CLODBOX_IMAGE_OVERRIDE"
  fi

  # Ensure container image is available (pull if needed, build as fallback)
  docker="${CLODBOX_DOCKER_CMD:-$(command -v podman 2>/dev/null || command -v docker 2>/dev/null)}"
  if [ -n "$docker" ]; then
    if ! "$docker" image inspect "$CLODBOX_CONTAINER_IMAGE" >/dev/null 2>&1; then
      printf "Container image not found locally. Pulling %s...\n" "$CLODBOX_CONTAINER_IMAGE" >&2
      if "$docker" pull "$CLODBOX_CONTAINER_IMAGE" 2>/dev/null; then
        printf "Image pulled successfully.\n" >&2
      else
        printf "Pull failed. Attempting local build...\n" >&2
        # Try to determine which Containerfile to use based on image name
        local containerfile=""
        case "$CLODBOX_CONTAINER_IMAGE" in
          *clodbox-base*|*clodbox:latest)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.base"
            ;;
          *clodbox-systems*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.systems"
            ;;
          *clodbox-jvm*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.jvm"
            ;;
          *clodbox-android*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.android"
            ;;
          *clodbox-ndk*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.ndk"
            ;;
          *clodbox-dotnet*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.dotnet"
            ;;
          *clodbox-behemoth*)
            containerfile="$CLODBOX_DATA_PATH/containers/Containerfile.behemoth"
            ;;
        esac

        if [ -n "$containerfile" ] && [ -f "$containerfile" ]; then
          "$docker" build -t "$CLODBOX_CONTAINER_IMAGE" \
            -f "$containerfile" \
            "$CLODBOX_DATA_PATH/containers/" || {
            echo "Error: Failed to pull or build container image: $CLODBOX_CONTAINER_IMAGE" >&2
            exit 1
          }
          printf "Image built successfully.\n" >&2
        else
          echo "Error: Container image not available and no local Containerfile found." >&2
          echo "Image: $CLODBOX_CONTAINER_IMAGE" >&2
          exit 1
        fi
      fi
    fi
  fi

  ENTRYPOINT_ARGS=()
  if [ -n "${CLODBOX_ENTRYPOINT:-}" ]; then
    ENTRYPOINT_ARGS=(--entrypoint "$CLODBOX_ENTRYPOINT")
  fi

  # Refresh auth credentials from central store into project copy.
  CENTRAL_CREDS="$CLODBOX_CREDENTIALS_PATH/$CLODBOX_DOT_PATH/.credentials.json"
  if [ -f "$CENTRAL_CREDS" ]; then
    jq --argjson auth "$(jq '.claudeAiOauth' "$CENTRAL_CREDS")" \
      '.claudeAiOauth = $auth' "$PROJECT_DOT_PATH/.credentials.json" \
      > "$PROJECT_DOT_PATH/.credentials.json.tmp" \
      && mv "$PROJECT_DOT_PATH/.credentials.json.tmp" "$PROJECT_DOT_PATH/.credentials.json"
  fi

  # Build CLI args to pass to the container entrypoint.
  CLI_ARGS=()

  # Determine if we're in claude mode (entrypoint is claude, not overridden).
  CLODBOX_CLAUDE_MODE=1
  if [ -n "${CLODBOX_ENTRYPOINT:-}" ]; then
    CLODBOX_CLAUDE_MODE=
  fi

  if [ -n "$CLODBOX_CLAUDE_MODE" ]; then
    # Inject --dangerously-skip-permissions unless --safe was passed.
    if [ -z "${CLODBOX_SAFE_MODE:-}" ]; then
      CLI_ARGS+=(--dangerously-skip-permissions)
    fi

    if [ -n "${CLODBOX_RESUME_MODE:-}" ]; then
      # Resume mode: inject --resume, skip --continue logic.
      CLI_ARGS+=(--resume)
    else
      # Default to --continue for existing projects, unless suppressed.
      SKIP_CONTINUE="${CLODBOX_NEW_SESSION:-}${CLODBOX_PROJECT_IS_NEW:-}"
      for arg in "$@"; do
        if [ "$arg" = "--resume" ] || [ "$arg" = "-r" ]; then
          SKIP_CONTINUE=1
        fi
      done
      if [ -z "$SKIP_CONTINUE" ]; then
        CLI_ARGS+=(--continue)
      fi
    fi
  fi

  CLI_ARGS+=("$@")

  # Execute podman or docker.
  docker run -it --rm --userns=keep-id \
    -v "$PROJECT_PATH":/home/agent/workspace:Z,U \
    -w /home/agent/workspace \
    -v "$PROJECT_DOT_PATH":/home/agent/.claude:Z,U \
    -v "$PROJECT_CFG_FILE":/home/agent/.claude.json:Z,U \
    "${ENTRYPOINT_ARGS[@]}" \
    "$CLODBOX_CONTAINER_IMAGE" \
    "${CLI_ARGS[@]}"
}

# Process standardized directories.
_clodbox_load_std_paths_() {
  # Fetch / normalize XDG variables (or get their defaults)
  XDG_DATA_HOME=$(_get_abspath_ "${XDG_DATA_HOME:-}" "$HOME/.local/share")
  XDG_STATE_HOME=$(_get_abspath_ "${XDG_STATE_HOME:-}" "$HOME/.local/state")
  XDG_CACHE_HOME=$(_get_abspath_ "${XDG_CACHE_HOME:-}" "$HOME/.cache")

  # The config has all over variables, so just this relative path is at the top;
  # it holds important values - all of the relative paths, as well as others
  # (CLODBOX_CREDENTIALS_PATH, CLODBOX_SETTINGS_PATH). Other standard paths use
  # the standard relative path loaded from the config file.

  if [ ! -f "$CLODBOX_CONFIG_FILE" ]; then
    echo "Error: [$CLODBOX_CONFIG_FILE] is missing. Reinstall to fix." >&2
    exit 1
  else
    . "$CLODBOX_CONFIG_FILE"
  fi

  CLODBOX_DATA_PATH="$XDG_DATA_HOME/$CLODBOX_RELATIVE_STD_PATH" # projects, creds.
  CLODBOX_STATE_PATH="$XDG_STATE_HOME/$CLODBOX_RELATIVE_STD_PATH" # Maybe for later
  CLODBOX_CACHE_PATH="$XDG_CACHE_HOME/$CLODBOX_RELATIVE_STD_PATH" # Maybe for later
  CLODBOX_CREDENTIALS_PATH="$CLODBOX_DATA_PATH/$CLODBOX_INIT_CREDENTIALS_PATH"

  # Make sure all of the directories exist.
  mkdir -p "$(dirname "$CLODBOX_CONFIG_FILE")"
  mkdir -p "$CLODBOX_DATA_PATH"
  mkdir -p "$CLODBOX_STATE_PATH"
  mkdir -p "$CLODBOX_CACHE_PATH"
}

# Fetch / construct and validate project paths.
_clodbox_fetch_project_paths_() {
  # Fetch / construct various project-related paths
  PROJECT_PATH="$(realpath -m "${CLODBOX_PROJECT_DIR:-$(pwd)}")"
  PROJECT_HASH=$(echo -n "$PROJECT_PATH" | sha256sum | cut -d " " -f1)

  PROJECT_SETTINGS_PATH="$CLODBOX_DATA_PATH/$CLODBOX_PROJECTS_PATH/$PROJECT_HASH"
  PROJECT_DOT_PATH="$PROJECT_SETTINGS_PATH/$CLODBOX_DOT_PATH"
  PROJECT_CFG_FILE="$PROJECT_SETTINGS_PATH/$CLODBOX_CFG_FILE"

  # If the project path doesn't exist... something is wrong.
  if [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Project path '$PROJECT_PATH' does not exist." >&2
    echo "(How did you get here?!)" >&2
    exit 1
  fi

  # If there's no data on the project, attempt to initialize it freshly.
  if [ ! -d "$PROJECT_SETTINGS_PATH" ]; then
    printf '[One Time Setup] Initializing clodbox in %s... ' "$PROJECT_PATH"
    _clodbox_init_
    printf "done.\n"
    CLODBOX_PROJECT_IS_NEW=1
  fi

  # If dot-path doesn't exist at this point, its a problem; attempt recovery.
  if [ ! -d "$PROJECT_DOT_PATH" ]; then
    echo "Warning: No settings directory; this is probably a problem." >&2
    echo "--> Making project settings directory for attempted start..."
    mkdir -p "$PROJECT_DOT_PATH"
    if [ ! -d "$PROJECT_DOT_PATH" ]; then
      echo "Error: *Still* no project settings directory. Exiting." >&2
      exit 1
    fi
  fi

  # Source per-project config if it exists (overrides global defaults).
  PROJECT_RC="$PROJECT_SETTINGS_PATH/project.rc"
  if [ -f "$PROJECT_RC" ]; then
    . "$PROJECT_RC"
  fi

  # If the config file doesn't exist, that's also a problem - attempt recovery.
  if [ ! -f "$PROJECT_CFG_FILE" ]; then
    echo "Warning: No project config file; this is probably a problem." >&2
    echo "--> Creating $PROJECT_CFG_FILE..."
    touch "$PROJECT_CFG_FILE"
    if [ ! -f "$PROJECT_CFG_FILE" ]; then
      echo "Error: *Still* no project config file. Exiting." >&2
      exit 1
    fi
  fi
}

# Initialize clodbox in current working path.
_clodbox_init_() {
  # Check if path exists. (It should always exist.)
  if [ ! -d "$PROJECT_PATH" ]; then
    echo "Function Error: clodbox project directory doesn't exist." >&2
    echo "(How did you get here?!)" >&2
    exit 1
  fi

  # Fetch project-specific path via hash. Generate missing directories.
  mkdir -p "$PROJECT_PATH"
  mkdir -p "$PROJECT_SETTINGS_PATH"

  # Copy credential files into the project configuration and exit.
  cp -rp "$CLODBOX_CREDENTIALS_PATH/." "$PROJECT_SETTINGS_PATH"
}

# Archive project session data and git metadata.

# Get or set per-project configuration.
_clodbox_config_() {
  local key="${1:-}"
  if [ -z "$key" ]; then
    echo "Usage: clodbox config <key> [value]" >&2
    echo "Keys: image" >&2
    exit 1
  fi

  case "$key" in
    image)
      if [ -z "${2:-}" ]; then
        echo "$CLODBOX_CONTAINER_IMAGE"
      else
        local rc="$PROJECT_SETTINGS_PATH/project.rc"
        if [ -f "$rc" ] && grep -q '^CLODBOX_CONTAINER_IMAGE=' "$rc"; then
          sed -i "s|^CLODBOX_CONTAINER_IMAGE=.*|CLODBOX_CONTAINER_IMAGE=\"$2\"|" "$rc"
        else
          echo "CLODBOX_CONTAINER_IMAGE=\"$2\"" >> "$rc"
        fi
        echo "Set image to $2 for project $PROJECT_PATH"
      fi
      ;;
    *)
      echo "Error: Unknown config key: $key" >&2
      exit 1
      ;;
  esac
}

# ---- Option Processing ----
_clodbox_usage_() {
  echo "Usage: clodbox [OPTIONS] [COMMAND] [-- AGENT_ARGS...]"
  echo ""
  echo "Commands:"
  echo "  start              Start or continue a Claude session (default)"
  echo "  shell              Open a bash shell in the container"
  echo "  resume             Resume with conversation picker"
  echo "  config             Get or set per-project configuration"
  echo "  archive <path> [file]  Archive project session data to .txz file"
  echo "  clean <path>       Remove project session data"
  echo "  restore <path> <file>  Restore session data from archive"
  echo ""
  echo "Options:"
  echo "  -c, --command CMD      Use CMD as the container entrypoint"
  echo "  -i, --image IMAGE      Use IMAGE as the container image for this run"
  echo "  -p, --project DIR      Use DIR as the project directory (default: cwd)"
  echo "  -N, --new              Start a new conversation (skip default --continue)"
  echo "  -S, --safe             Run without --dangerously-skip-permissions"
  echo "  -h, --help             Show this help message"
  echo ""
  echo "Archive/Clean/Restore Options:"
  echo "  --allow-uncommitted    Allow archiving with uncommitted changes"
  echo "  --allow-unpushed       Allow archiving with unpushed commits"
  echo "  --force                Skip all confirmation prompts"
  echo ""
  echo "By default, existing projects resume the last conversation. Use -N to"
  echo "start fresh, or pass explicit agent args after -- to override."
}

CLODBOX_SUBCOMMAND=
CLODBOX_ALLOW_UNCOMMITTED=
CLODBOX_ALLOW_UNPUSHED=
CLODBOX_FORCE=

while [ $# -gt 0 ]; do
  case "$1" in
    --allow-uncommitted)
      CLODBOX_ALLOW_UNCOMMITTED=1
      shift
      ;;
    --allow-unpushed)
      CLODBOX_ALLOW_UNPUSHED=1
      shift
      ;;
    --force)
      CLODBOX_FORCE=1
      shift
      ;;
    -c|--command|-E|--entrypoint)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_ENTRYPOINT="$2"
      shift 2
      ;;
    -i|--image)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_IMAGE_OVERRIDE="$2"
      shift 2
      ;;
    -p|--project)
      if [ -z "${2:-}" ]; then
        echo "Error: $1 requires an argument." >&2
        exit 1
      fi
      CLODBOX_PROJECT_DIR="$2"
      shift 2
      ;;
    -N|--new)
      CLODBOX_NEW_SESSION=1
      shift
      ;;
    -S|--safe)
      CLODBOX_SAFE_MODE=1
      shift
      ;;
    -h|--help)
      _clodbox_usage_
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      _clodbox_usage_ >&2
      exit 1
      ;;
    start|shell|resume|config|archive|clean|restore)
      CLODBOX_SUBCOMMAND="$1"
      shift
      break
      ;;
    *)
      echo "Error: Unknown command: $1" >&2
      _clodbox_usage_ >&2
      exit 1
      ;;
  esac
done

# Default subcommand is start.
CLODBOX_SUBCOMMAND="${CLODBOX_SUBCOMMAND:-start}"

# Apply subcommand effects.
case "$CLODBOX_SUBCOMMAND" in
  config)
    exec "$(dirname "$(realpath "$0")")/clodbox-config" "$@"
    ;;
  archive)
    # Pass through flags as environment variables
    export CLODBOX_ALLOW_UNCOMMITTED CLODBOX_ALLOW_UNPUSHED CLODBOX_FORCE
    exec "$(dirname "$(realpath "$0")")/clodbox-archive" "$@"
    ;;
  clean)
    export CLODBOX_FORCE
    exec "$(dirname "$(realpath "$0")")/clodbox-clean" "$@"
    ;;
  restore)
    export CLODBOX_FORCE
    exec "$(dirname "$(realpath "$0")")/clodbox-restore" "$@"
    ;;
  shell)
    CLODBOX_ENTRYPOINT="/bin/bash"
    ;;
  resume)
    CLODBOX_RESUME_MODE=1
    ;;
esac

# Kickoff the script; forward any remaining args to the container.
_clodbox_start_ "$@"
